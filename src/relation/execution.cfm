<cffunction name="toSql" returntype="string" access="public" hint="Convert relational data into a SQL string">
	<cfscript>
		
		// run mappings before converting to SQL
		_applyMappings();
		
		return this.visitor.visit(this);
	</cfscript>
</cffunction>

<cffunction name="exec" returntype="struct" access="public" hint="Run query() but return the relation">
	<cfargument name="callbacks" type="boolean" default="true" />
	<cfscript>
		this.query(argumentCollection=arguments);
		return this;
	</cfscript>
</cffunction>

<cffunction name="reload" returntype="struct" access="public" hint="Execute again to reload dataset">
	<cfargument name="callbacks" type="boolean" default="true" />
	<cfscript>
		variables.executed = false;
		return this.exec(argumentCollection=arguments);
	</cfscript>
</cffunction>

<cffunction name="query" returntype="query" access="public" hint="Lazily execute and return query object">
	<cfargument name="callbacks" type="boolean" default="true" />
	<cfargument name="allowSpecialPaging" type="boolean" default="false" />
	<cfscript>
		var loc = {};
				
		// run before find callbacks on relation
		if (arguments.callbacks)
			this.mapper.beforeFind(this);
		
		// drop into query logic if we don't have a query yet
		if (variables.executed EQ false OR NOT StructKeyExists(variables.cache, "query")) {
			clearCache();
			
			// do some special handling for paged SqlServer queries with aggregates
			if (arguments.allowSpecialPaging AND variables.visitorClass EQ "SqlServer" AND variables.paged AND ArrayLen(this.sql.groups)) {
				
				// get values for rows that don't use aggregates
				loc.valueRel = minimizedRelation();
				loc.valueQuery = loc.valueRel.query(false, false);
				
				// create a new clone without pagination
				loc.dataRel = clone().clearPagination();
				
				// loop over items that were in last select
				loc.iEnd = ArrayLen(loc.valueRel.sql.select);
				for (loc.i = 1; loc.i LTE loc.iEnd; loc.i++) {
					
					// get key + value list for 
					loc.item = loc.valueRel.sql.select[loc.i];
					loc.key = loc.item.alias;
					loc.keyValues = ListToArray(Evaluate("ValueList(loc.valueQuery.#loc.key#, Chr(7))"), Chr(7));
					
					// add new where clause entries for IN statements
					loc.dataRel.where(sqlBinaryOp(left=loc.item, op='IN', right='(?)'), [loc.keyValues]);
				}
				
				// save objects into current relation
				variables.cache.query = loc.dataRel.query(arguments.callbacks, false);
				variables.cache.result = loc.dataRel.result();
			
			} else {
				
				// set up arguments for query execution
				loc.queryArgs = {};
				loc.queryArgs.sql = this.toSql();
				
				// use max rows if specified
				if (this.maxRows GT 0)
					loc.queryArgs.maxRows = this.maxRows;
				
				// if we are using query of a query, set dbtype and resultsets
				if (variables.qoq) {
					loc.queryArgs.dbType = "query";
					loc.iEnd = ArrayLen(this.sql.froms);
					for (loc.i = 1; loc.i LTE loc.iEnd; loc.i++)
						loc.queryArgs["query" & loc.i] = this.sql.froms[loc.i];
					
				} else {
			
					// set up a datasource
					if (Len(this.datasource) EQ 0)
						throwException("Cannot execute query without a datasource");
					loc.queryArgs.datasource = this.datasource;
				}
				
				// execute query using a wrapper
				$executeQuery(argumentCollection=loc.queryArgs);
				
				// run after find callbacks on query
				if (arguments.callbacks AND IsObject(this.model))
					this.mapper.afterFind(this.model, variables.cache.query);
				
				// set up looping counter
				variables.currentRow = 0;
			}
			
			// build pagination data
			// todo: lazy loading?
			if (variables.paged) {
				variables.paginationData = {
					currentPage = (this.sql.offset / this.sql.limit) + 1,
					perPage = this.sql.limit
				};
			}
			
			// change state
			variables.executed = true;
		}
		
		return variables.cache.query;
	</cfscript>
</cffunction>

<cffunction name="result" returntype="struct" access="public" hint="Return result object generated by query()">
	<cfscript>
		if (variables.executed EQ false OR NOT StructKeyExists(variables.cache, "result"))
			this.query();
		return variables.cache.result;
	</cfscript>
</cffunction>

<cffunction name="pagination" returntype="struct" access="public" hint="Return structure describing pagination state">
	<cfscript>
		if (variables.paged EQ false OR NOT IsStruct(variables.paginationData))
			return false;
		return variables.paginationData;
	</cfscript>
</cffunction>

<cffunction name="$executeQuery" returntype="void" access="private" hint="Execute a cfquery with parameters">
	<cfargument name="sql" type="string" required="true" hint="Query string to execute" />
	<cfargument name="params" type="array" default="#ArrayNew(1)#" hint="Array of cfqueryparam arguments" />
	<cfscript>
		var loc = {};
		
		// find and mark positional parameters
		loc.regex = "(^[^']*(?:'[^']*'[^']*)*)\?";
		while (REFind(loc.regex, arguments.sql))
			arguments.sql = REReplace(arguments.sql, loc.regex, "\1" & Chr(7) & "__PARAM__" & Chr(7), "ALL");
			
		// split sql string into an array at positional parameters
		loc.sql = ListToArray(arguments.sql, Chr(7));
		
		// loop over and add params to sql structure
		loc.iEnd = ArrayLen(loc.sql);
		for (loc.i = 1; loc.i LTE loc.iEnd; loc.i++) {
			if (loc.sql[loc.i] EQ "__PARAM__") {
				
				// add an existing parameter from relation
				if (ArrayLen(arguments.params) GT 0) {
					loc.sql[loc.i] = arguments.params[1];
					ArrayDeleteAt(arguments.params, 1);
				
				// or set up a NULL parameter
				} else {
					loc.sql[loc.i] = StructNew();
					loc.sql[loc.i].null = true;
				}
			}
		}
		
		// remove positional params and sql from arguments
		StructDelete(arguments, "sql");
		StructDelete(arguments, "params");
	</cfscript>
	<cfquery name="variables.cache.query" result="variables.cache.result" attributeCollection="#arguments#">
		<cfloop array="#loc.sql#" index="loc.fragment"><cfif IsStruct(loc.fragment)><cfqueryparam attributeCollection="#loc.fragment#" /><cfelse>#PreserveSingleQuotes(loc.fragment)#</cfif></cfloop>
	</cfquery>
</cffunction>
